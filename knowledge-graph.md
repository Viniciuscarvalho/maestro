# Knowledge Graph & Continuous Learning

Specification for the project intelligence system that builds understanding over time. This is what makes the orchestrator get smarter with each task.

---

## Core Concept

The knowledge graph is a set of markdown files that capture project-specific intelligence. Unlike skills (which are general knowledge), the knowledge graph contains learnings specific to THIS project: its patterns, idioms, decisions, and gaps.

```
.claude/knowledge/           ‚Üê Lives in the project
‚îú‚îÄ‚îÄ context.yaml             ‚Üê Project scan results (auto-generated)
‚îú‚îÄ‚îÄ patterns.md              ‚Üê Discovered code patterns
‚îú‚îÄ‚îÄ decisions.md             ‚Üê Architecture decision records
‚îú‚îÄ‚îÄ skill-gaps.md            ‚Üê Missing skills and workarounds
‚îî‚îÄ‚îÄ learnings.md             ‚Üê Insights from completed tasks
```

---

## context.yaml ‚Äî Project Context

Auto-generated by the project scanner. Updated when project configuration changes.

```yaml
# Auto-generated by skill-orchestrator
# Last updated: 2026-02-26

project:
  name: "MyApp"
  language: swift
  swift_version: "6.0"
  platforms:
    ios: "17.0"
    macos: "14.0"

architecture:
  pattern: MVVM
  layers: [View, ViewModel, Repository, UseCase]
  di: constructor-injection
  navigation: NavigationStack + Coordinator

concurrency:
  strict_checking: complete
  default_isolation: MainActor
  swift_language_mode: "6"

skills_loaded:
  - swift-best-practices
  - swift-concurrency
  - swift-testing-expert
  - swiftui-expert-skill
  - swift-code-reviewer

dependencies:
  - { name: Alamofire, version: "5.9", domain: networking }
  - { name: Kingfisher, version: "8.0", domain: images }
```

---

## patterns.md ‚Äî Discovered Patterns

Updated by the orchestrator as it works through tasks. Captures project-specific patterns that skills don't cover.

```markdown
# Project Patterns

## Networking
- All API calls go through `NetworkService` actor
- Responses are decoded using `APIResponse<T>` wrapper
- Errors are mapped to `AppError` enum before propagation
- Rate limiting is handled at the `NetworkService` level

## ViewModels
- All ViewModels use `@Observable` with `@MainActor`
- Naming: `{Feature}ViewModel` (e.g., `LoginViewModel`)
- All ViewModels have a `Task` property for async work lifecycle
- Loading state uses shared `LoadingState<T>` enum

## Navigation
- Coordinators own NavigationPath
- Deep links are handled by `DeepLinkRouter`
- Sheet presentation uses `.sheet(item:)` pattern
- Tab selection stored in `AppState`

## Error Handling
- All errors conform to `AppError` protocol
- User-facing errors use `LocalizedError`
- Logging uses OSLog with subsystem per module
- Network errors are automatically retried once

## Testing
- Fixtures use static factory pattern: `User.fixture(name: "Test")`
- SpyingStubs placed in `-Interface` modules with `#if DEBUG`
- All async tests use `@Test` with `async throws`
- Integration tests use `TestContainer` for DI
```

---

## decisions.md ‚Äî Architecture Decision Records

Lightweight ADRs captured when the orchestrator encounters or helps make architecture decisions.

```markdown
# Architecture Decisions

## ADR-001: @Observable over ObservableObject
**Date**: 2026-01-15
**Context**: Migrating state management to iOS 17+ patterns
**Decision**: Use @Observable for all new ViewModels
**Rationale**: Better performance (fine-grained tracking), simpler code, nesting works
**Consequences**: Minimum deployment target iOS 17

## ADR-002: Actor for NetworkService
**Date**: 2026-01-20  
**Context**: Protecting shared URLSession and cache state
**Decision**: NetworkService is an actor, not a class
**Rationale**: Compiler-enforced thread safety, no manual locking
**Consequences**: All call sites must use await

## ADR-003: Swift Testing for new tests
**Date**: 2026-02-01
**Context**: Choosing test framework for new test targets
**Decision**: Use Swift Testing (@Test, #expect) for all new tests
**Rationale**: Better parameterization, cleaner syntax, built-in tags
**Consequences**: Keep existing XCTest, don't migrate retroactively
```

---

## skill-gaps.md ‚Äî Missing Knowledge

Tracks domains where the orchestrator couldn't find a matching skill.

```markdown
# Skill Gaps

## Active Gaps

### Coordinator Navigation Pattern
**Encountered**: 2026-02-10
**Context**: Project uses Coordinator pattern but no skill covers it
**Workaround**: Following patterns from CLAUDE.md and existing Coordinators
**Suggested skill**: coordinator-navigation-skill covering:
  - Coordinator lifecycle
  - Deep linking integration
  - Tab-based coordination
  - Child coordinator management

### Alamofire Best Practices
**Encountered**: 2026-02-15
**Context**: Project uses Alamofire 5.9 but no skill covers its patterns
**Workaround**: Following official Alamofire docs and project conventions
**Suggested skill**: alamofire-patterns covering:
  - Request/Response interceptors
  - Authentication handling
  - Retry policies
  - Multipart upload patterns

## Resolved Gaps

### SwiftUI Performance (resolved 2026-02-20)
**Resolution**: Installed swiftui-expert-skill which covers performance-patterns.md
```

---

## learnings.md ‚Äî Task Insights

Captured after significant tasks to build institutional knowledge.

```markdown
# Task Learnings

## 2026-02-25: Login Screen Implementation
**Task**: Build login screen with biometric auth
**Skills used**: swiftui-expert-skill, swift-concurrency, swift-code-reviewer
**Key learnings**:
- Project uses `BiometricService` actor for Face ID / Touch ID
- Credentials stored via `KeychainService` (not UserDefaults)
- Login flow: email/password ‚Üí API ‚Üí token ‚Üí Keychain ‚Üí navigate
- Error states displayed using `AlertModifier` pattern

## 2026-02-24: Swift 6 Migration (Networking Module)
**Task**: Fix Sendable warnings in networking layer
**Skills used**: swift-concurrency (sendable.md, actors.md, migration.md)
**Key learnings**:
- `URLSession.shared` is Sendable, no wrapping needed
- Response models needed explicit Sendable (already value types)
- Interceptors required `@Sendable` closures
- Migration was module-by-module, ~2 hours per module
```

---

## Update Protocol

### When to Update the Knowledge Graph

```
After EVERY significant task:
1. Did I discover a new project pattern? ‚Üí Update patterns.md
2. Did an architecture decision get made? ‚Üí Add to decisions.md
3. Did I encounter a skill gap? ‚Üí Log in skill-gaps.md
4. Did I learn something reusable? ‚Üí Add to learnings.md
5. Did project config change? ‚Üí Regenerate context.yaml
```

### How to Update

The orchestrator should update the knowledge graph as a natural part of task completion, not as a separate step. Updates should be:

- **Concise**: 2-3 sentences per learning
- **Actionable**: Future tasks should benefit from this knowledge
- **Dated**: Always include when the learning occurred
- **Scoped**: Tag with relevant domains/skills

### Update Triggers

```
Automatic triggers:
- New dependency detected ‚Üí update context.yaml
- CLAUDE.md modified ‚Üí rescan, update context.yaml
- New skill installed ‚Üí update context.yaml, check resolved gaps
- Architecture discussion ‚Üí prompt for ADR

Manual triggers (suggest to user):
- Major refactoring completed ‚Üí capture patterns
- Sprint retrospective ‚Üí capture learnings
- New team member onboarding ‚Üí review knowledge graph
```

---

## Skill Gap Analysis

### Detection

The orchestrator detects skill gaps when:

1. **No skill matches a domain**: Task involves Combine/RxSwift but no reactive skill exists
2. **Reference file doesn't exist**: Skill references `core-data.md` but file is missing
3. **Project uses unlisted dependency**: Alamofire patterns aren't covered by any skill
4. **Repeated workarounds**: The same manual pattern appears in 3+ tasks

### Recommendation Format

When a gap is detected, suggest:

```markdown
üí° **Skill Suggestion**: {domain-name}

I noticed this project uses {technology/pattern} which isn't covered by
any installed skill. I'm applying general best practices, but a 
dedicated skill would help with:

- {specific area 1}
- {specific area 2}
- {specific area 3}

Would you like me to create a basic skill for this domain?
```

### Creating Skills from Gaps

If the user agrees, the orchestrator can create a minimal skill:

1. Create `~/.claude/skills/{skill-name}/SKILL.md` with:
   - Frontmatter (name, description, triggers)
   - Core patterns observed in the project
   - References to official documentation
   
2. Create `references/` with:
   - Patterns extracted from existing code
   - Best practices from documentation
   
3. Add to the skill registry automatically

---

## Integration with Memory

The knowledge graph complements Claude's memory system:

```
Claude Memory:
  - User preferences (formatting, communication style)
  - Cross-project knowledge (user's expertise, common tools)
  - Persistent across all conversations

Knowledge Graph:
  - Project-specific patterns and decisions
  - Skill routing intelligence
  - Lives in the project repository
  - Shared with team (via git)
```

The orchestrator should use BOTH:
- Memory for understanding the developer's style and preferences
- Knowledge graph for understanding the project's patterns and rules
